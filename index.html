<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Image Generation UI</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{--bg:#0f1115;--card:#171a21;--muted:#9aa3b2;--text:#e6e9ef;--accent:#ff6b6b;--ok:#2ecc71;--warn:#f1c40f}
    body{margin:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial}
    .wrap{max-width:1200px;margin:0 auto;padding:16px;display:grid;grid-template-columns:1fr 1fr;gap:16px}
    .card{background:var(--card);border-radius:12px;padding:16px;box-shadow:0 0 0 1px rgba(255,255,255,.04) inset}
    h2{margin:0 0 12px;font-size:16px}
    label{display:block;margin:8px 0 6px;color:var(--muted);font-size:13px}
    select,textarea,input[type="text"]{width:100%;background:#0c0f14;border:1px solid #242b36;color:var(--text);
      border-radius:10px;padding:10px 12px;outline:none}
    textarea{min-height:120px;resize:vertical}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .btns{display:flex;gap:8px;margin-top:12px}
    button{border:0;background:var(--accent);color:#fff;padding:10px 14px;border-radius:10px;cursor:pointer}
    button.outline{background:transparent;border:1px solid #2b3340;color:var(--text)}
    button:disabled{opacity:0.5;cursor:not-allowed}
    .status{font-size:13px;color:var(--muted)}
    .log{height:200px;overflow:auto;background:#0b0e13;border-radius:10px;padding:10px;font:12px/1.4 ui-monospace,Menlo,Consolas}
    .kv{display:grid;grid-template-columns:110px 1fr;gap:10px}
    .images{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:10px}
    .images img{width:100%;height:180px;object-fit:cover;border-radius:10px;background:#0b0e13}
    .muted{color:var(--muted)}
    .ok{color:var(--ok)} .warn{color:var(--warn)}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    .progress-bar{width:100%;height:4px;background:#242b36;border-radius:2px;overflow:hidden;margin:8px 0}
    .progress-fill{height:100%;background:var(--accent);transition:width 0.3s ease}

    /* --- Responsive: stack to one column on mobile --- */
    @media (max-width: 768px){
      .wrap{grid-template-columns:1fr;}
      .row{grid-template-columns:1fr;}
      /* optional quality-of-life tweaks on small screens */
      .kv{grid-template-columns:1fr;}
      .images{grid-template-columns:1fr;}
    }
  </style>
</head>
<body>
  <div class="wrap">

    <!-- Left: form -->
    <div class="card">
      <h2>Generate Images</h2>
      <div class="row">
        <div>
          <label>AI Model</label>
          <select id="model">
            <option value="indian_female" selected>Indian (female)</option>
            <option value="indian_male">Indian (male)</option>
            <option value="american_female">American (female)</option>
            <option value="american_male">American (male)</option>
            <option value="korean_female">Korean (female)</option>
            <option value="korean_male">Korean (male)</option>
          </select>
        </div>
        <div>
          <label>Image Count</label>
          <select id="count">
            <option>1</option><option>2</option><option>3</option><option>4</option>
            <option selected>5</option>
          </select>
        </div>
      </div>
      <div class="row">
        <div>
          <label>Market</label>
          <select id="market">
            <option value="in" selected>Indian</option>
            <option value="am">America</option>
            <option value="kr">Korean</option>
          </select>
        </div>
        <div>
          <label>Job ID (optional)</label>
          <input id="jobId" type="text" placeholder="Enter existing job ID" />
        </div>
      </div>

      <label>Prompt</label>
      <textarea id="prompt" placeholder="Describe what you want to generate...">Goal:
Generate a 5-image Instagram carousel showcasing Indian travelers enjoying Columbia Pictures Aquaverse Thailand â€” tropical, cinematic, family-friendly, and emotionally relatable.</textarea>

      <div class="btns">
        <button id="submit">Generate Images</button>
        <button class="outline" id="checkStatus">Check Status</button>
        <button class="outline" id="reset">Reset</button>
      </div>

      <div class="progress-bar">
        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
      </div>

      <div class="kv">
        <div class="muted">Job ID</div>
        <div class="mono" id="currentJobId">â€“</div>
        <div class="muted">Status</div>
        <div class="status" id="status">Ready</div>
      </div>

      <h2 style="margin-top:18px">Activity Log</h2>
      <div class="log" id="log"></div>
    </div>

    <!-- Right: output -->
    <div class="card">
      <h2>Generated Images</h2>
      <div id="images" class="images">
        <div class="muted" style="text-align:center;padding:60px 20px">
          Images will appear here when generation is complete
        </div>
      </div>

      <h2 style="margin-top:18px">Response Data</h2>
      <pre id="json" class="log">{}</pre>
    </div>

  </div>

<script>
// =========================
// Configuration
// =========================
const WEBHOOK_START  = "https://saschag.app.n8n.cloud/webhook/gen/start";
const WEBHOOK_STATUS = "https://saschag.app.n8n.cloud/webhook/gen/status";

// ðŸ‘‰ Your webhook that receives the final post
const WEBHOOK_POST   = "https://saschag.app.n8n.cloud/webhook/725f851d-20d5-426f-bfcc-522dae7472d3";

// =========================
/** DOM helpers */
// =========================
const el = (id) => document.getElementById(id);
const $log = el('log'), $json = el('json'), $imgs = el('images');
const $jobId = el('currentJobId'), $status = el('status');
const $progressFill = el('progressFill');

function fixJSONContainer() {
  if ($json) {
    $json.style.overflowX = 'auto';
    $json.style.whiteSpace = 'pre-wrap';
    $json.style.wordWrap = 'break-word';
    $json.style.maxWidth = '100%';
    $json.style.boxSizing = 'border-box';
  }
}

// =========================
/** State */
// =========================
let currentJobId = null;
let pollInterval = null;
let pollAttempts = 0;
const MAX_POLL_ATTEMPTS = 180;

let lastHtml = null;
let lastImages = [];
let lastRawResponse = null;
let currentMarket = null;

// =========================
/** Logging & UI */
// =========================
function log(message, isError = false) {
  const timestamp = new Date().toLocaleTimeString();
  const color = isError ? 'color:var(--warn)' : '';
  $log.innerHTML += `<div style="${color}">[${timestamp}] ${message}</div>`;
  $log.scrollTop = $log.scrollHeight;
}

function updateProgress(percent) {
  const pct = Math.max(0, Math.min(100, Number(percent) || 0));
  $progressFill.style.width = `${pct}%`;
}

function showImages(imageUrls) {
  lastImages = Array.isArray(imageUrls) ? imageUrls : [];
  if (!imageUrls || imageUrls.length === 0) {
    const htmlContainer = el('htmlContainer');
    if (!htmlContainer || htmlContainer.innerHTML.includes('No HTML provided')) {
      $imgs.innerHTML = '<div class="muted" style="text-align:center;padding:60px 20px">No images generated</div>';
    } else {
      $imgs.innerHTML = '';
    }
    return;
  }

  $imgs.innerHTML = '';
  imageUrls.forEach(url => {
    const container = document.createElement('div');
    const img = document.createElement('img');
    img.src = url;
    img.alt = 'Generated image';
    img.style.width = '100%';
    img.style.height = '180px';
    img.style.objectFit = 'cover';
    img.style.borderRadius = '10px';
    img.style.background = '#0b0e13';
    container.appendChild(img);
    $imgs.appendChild(container);
  });
}

function showJSON(data) {
  lastRawResponse = data;
  try {
    $json.textContent = JSON.stringify(data, null, 2);
  } catch {
    $json.textContent = String(data);
  }
  fixJSONContainer();
}

// =========================
/** Post to Make.com */
// =========================
async function postToMake(buttonEl) {
  if (!WEBHOOK_POST || WEBHOOK_POST.includes('REPLACE_WITH_YOUR_MAKE_WEBHOOK')) {
    log('WEBHOOK_POST is not set. Please replace with your Make.com webhook URL.', true);
    return;
  }
  if (!lastHtml) {
    log('No HTML to post.', true);
    return;
  }

  try {
    if (buttonEl) {
      buttonEl.disabled = true;
      buttonEl.textContent = 'Posting...';
    }

    // Capture selected market
    const marketEl = el('market');
    let selectedMarketValue = currentMarket;
    let selectedMarketLabel = null;
    
    if (marketEl) {
      selectedMarketValue = marketEl.value;
      selectedMarketLabel = marketEl.options[marketEl.selectedIndex]?.text || selectedMarketValue;
    }

    const payload = {
      jobId: currentJobId || null,
      html: lastHtml,
      images: lastImages || [],
      market: selectedMarketValue,
      marketLabel: selectedMarketLabel,
      timestamp: new Date().toISOString(),
      raw: lastRawResponse || {}
    };

    log(`Sending HTML to Make.com webhook with market: ${selectedMarketLabel} (${selectedMarketValue})...`);
    
    const res = await fetch(WEBHOOK_POST, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    if (!res.ok) {
      const text = await res.text().catch(() => '');
      throw new Error(`HTTP ${res.status}: ${res.statusText}${text ? ' - ' + text : ''}`);
    }

    log('Posted to Make.com successfully âœ…');
    if (buttonEl) {
      buttonEl.textContent = 'Posted!';
      setTimeout(() => {
        buttonEl.textContent = 'Post to Make';
        buttonEl.disabled = false;
      }, 1200);
    }
  } catch (err) {
    log(`Error posting to Make.com: ${err.message}`, true);
    if (buttonEl) {
      buttonEl.textContent = 'Post to Make';
      buttonEl.disabled = false;
    }
  }
}

// =========================
/** Auto-post to Make.com when generation completes */
// =========================
async function autoPostToMake() {
  if (!WEBHOOK_POST || WEBHOOK_POST.includes('https://hook.eu2.make.com/3p41sllju4fqdkdu8stxuddac6whxn5a')) {
    log('WEBHOOK_POST is not set. Skipping auto-post.', true);
    return;
  }

  try {
    log('Auto-posting generation results to Make.com...');

    // Capture selected market
    const marketEl = el('market');
    let selectedMarketValue = currentMarket;
    let selectedMarketLabel = null;
    
    if (marketEl) {
      selectedMarketValue = marketEl.value;
      selectedMarketLabel = marketEl.options[marketEl.selectedIndex]?.text || selectedMarketValue;
    }

    const payload = {
      jobId: currentJobId || null,
      html: lastHtml,
      images: lastImages || [],
      market: selectedMarketValue,
      marketLabel: selectedMarketLabel,
      timestamp: new Date().toISOString(),
      raw: lastRawResponse || {},
      autoPosted: true
    };

    log(`Auto-posting to Make.com with market: ${selectedMarketLabel} (${selectedMarketValue})...`);
    
    const res = await fetch(WEBHOOK_POST, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    if (!res.ok) {
      const text = await res.text().catch(() => '');
      throw new Error(`HTTP ${res.status}: ${res.statusText}${text ? ' - ' + text : ''}`);
    }

    log('Auto-posted to Make.com successfully âœ…');
  } catch (err) {
    log(`Error auto-posting to Make.com: ${err.message}`, true);
  }
}

// =========================
/** Fixed HTML display with Post button */
// =========================
function showHTML(htmlString) {
  // Create container if it doesn't exist
  let container = el('htmlContainer');
  if (!container) {
    container = document.createElement('div');
    container.id = 'htmlContainer';
    container.style.margin = '16px 0';
    container.style.padding = '16px';
    container.style.border = '1px solid #2a2f3a';
    container.style.borderRadius = '10px';
    container.style.background = '#0b0e13';
    $imgs.parentNode.insertBefore(container, $imgs);
  }

  if (!htmlString) {
    container.innerHTML = '<div class="muted">No HTML provided.</div>';
    lastHtml = null;
    return;
  }

  // Parse & sanitize
  const tempDiv = document.createElement('div');
  tempDiv.innerHTML = htmlString;

  // Remove potentially unsafe tags
  tempDiv.querySelectorAll('script,style,link,meta').forEach(n => n.remove());
  // Strip all inline styles and classes for safety
  tempDiv.querySelectorAll('*').forEach(elm => {
    elm.removeAttribute('style');
    elm.removeAttribute('class');
  });

  const cleanHtml = tempDiv.innerHTML;
  lastHtml = cleanHtml;

  // Build UI with a Post button
  container.innerHTML = `
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
      <div style="font-weight:600;color:#9ca3af;">HTML Output</div>
      <div>
        <button id="postToMakeBtn" style="border:0;background:var(--accent);color:#fff;padding:8px 12px;border-radius:10px;cursor:pointer">Post to Make</button>
      </div>
    </div>
    <div style="
      background: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 10px;
      max-height: 400px;
      overflow: auto;
      color: black;
    ">
      ${cleanHtml}
    </div>
  `;

  // Ensure images fit
  const contentDiv = container.querySelector('div:last-child');
  contentDiv.querySelectorAll('img').forEach(img => {
    img.style.width = '100%';
    img.style.height = 'auto';
    img.style.maxWidth = '100%';
  });

  // Wire up the Post button
  const btn = el('postToMakeBtn');
  if (btn) btn.addEventListener('click', () => postToMake(btn));

  // Clear the images grid (since we're showing HTML instead)
  $imgs.innerHTML = '';

  log('HTML output displayed');
}

// =========================
/** Helpers to detect completion & extract HTML */
// =========================
function stopPolling() {
  if (pollInterval) {
    clearInterval(pollInterval);
    pollInterval = null;
  }
}

function isComplete(data) {
  const status = (data?.status || '').toString().toLowerCase();
  const progress = Number(data?.progress ?? 0);
  const finished = Boolean(data?.finished);
  const doneStatus = ['complete', 'done', 'success', 'finished'].includes(status);
  return doneStatus && (progress >= 100 || finished === true);
}

function getHtmlFromResponse(data) {
  if (!data || typeof data !== 'object') return undefined;
  if (typeof data.html === 'string') return data.html;
  if (typeof data?.data?.html === 'string') return data.data.html;
  if (typeof data?.result?.html === 'string') return data.result.html;
  const candidates = [data.data, data.result, data.payload];
  for (const c of candidates) {
    if (c && typeof c === 'object' && typeof c.html === 'string') return c.html;
  }
  return undefined;
}

// =========================
/** Status polling */
// =========================
async function checkWorkflowStatus() {
  if (!currentJobId) return;

  try {
    pollAttempts++;
    if (pollAttempts > MAX_POLL_ATTEMPTS) {
      log('Timeout - workflow taking too long', true);
      $status.textContent = 'Timeout';
      stopPolling();
      updateProgress(0);
      return;
    }

    const url = `${WEBHOOK_STATUS}?execId=${encodeURIComponent(currentJobId)}&_=${Date.now()}`;
    log(`Checking status (attempt ${pollAttempts})...`);

    const response = await fetch(url);
    if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);

    const data = await response.json();
    showJSON(data);

    if (isComplete(data)) {
      log('Workflow completed!');
      $status.textContent = 'Complete';
      updateProgress(100);
      stopPolling();

      const html = getHtmlFromResponse(data);
      if (html) {
        showHTML(html);
        $imgs.innerHTML = '';
      } else {
        if (Array.isArray(data.images) && data.images.length > 0) {
          showImages(data.images);
        } else {
          showImages([]);
        }
      }

      // Auto-post to Make.com when generation is complete
      setTimeout(() => {
        autoPostToMake();
      }, 1000);
      
      return;
    }

    $status.textContent = `Processing...`;
    const softProgress = Math.min(20 + (pollAttempts * 2), 95);
    updateProgress(softProgress);

  } catch (error) {
    log(`Error checking status: ${error.message}`, true);
    $status.textContent = 'Error checking status';
  }
}

// =========================
/** Start generation */
// =========================
async function startGeneration() {
  const existingJobId = el('jobId').value.trim();

  stopPolling();
  pollAttempts = 0;
  lastHtml = null;
  lastImages = [];
  lastRawResponse = null;

  // Store current market
  currentMarket = el('market').value;

  if (existingJobId) {
    currentJobId = existingJobId;
    $jobId.textContent = currentJobId;
    $status.textContent = 'Monitoring existing job...';
    log(`Monitoring existing job: ${existingJobId}`);
    pollInterval = setInterval(checkWorkflowStatus, 10000);
    checkWorkflowStatus();
    return;
  }

  const requestBody = {
    model: el('model').value,
    count: parseInt(el('count').value),
    market: currentMarket,
    prompt: el('prompt').value,
    slides: []
  };

  try {
    log(`Starting image generation for market: ${currentMarket}...`);
    $status.textContent = 'Starting...';
    updateProgress(10);

    const response = await fetch(WEBHOOK_START, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody)
    });

    if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);

    const data = await response.json();
    showJSON(data);
    log('Workflow started successfully');

    currentJobId = data.execId || data.jobId || data.id;
    if (!currentJobId) throw new Error('No job ID returned from server');

    $jobId.textContent = currentJobId;

    if (isComplete(data)) {
      log('Workflow completed immediately!');
      $status.textContent = 'Complete';
      updateProgress(100);
      stopPolling();

      const html = getHtmlFromResponse(data);
      if (html) {
        showHTML(html);
      } else {
        if (Array.isArray(data.images) && data.images.length > 0) showImages(data.images);
      }

      // Auto-post to Make.com when generation is complete
      setTimeout(() => {
        autoPostToMake();
      }, 1000);
    } else {
      $status.textContent = 'Processing...';
      updateProgress(20);
      log(`Job ID: ${currentJobId}`);
      log('Polling status every 10 seconds...');
      pollInterval = setInterval(checkWorkflowStatus, 10000);
    }

  } catch (error) {
    log(`Error starting generation: ${error.message}`, true);
    $status.textContent = 'Error';
    updateProgress(0);
  }
}

// =========================
/** Manual status check */
// =========================
function manualStatusCheck() {
  const manualJobId = el('jobId').value.trim();
  if (manualJobId) {
    currentJobId = manualJobId;
    $jobId.textContent = currentJobId;
    $status.textContent = 'Checking...';
    log(`Manual check for job: ${currentJobId}`);
    checkWorkflowStatus();
  } else if (currentJobId) {
    log(`Manual check for current job: ${currentJobId}`);
    checkWorkflowStatus();
  } else {
    log('No job ID to check', true);
  }
}

// =========================
/** Reset UI */
// =========================
function resetUI() {
  stopPolling();
  currentJobId = null;
  pollAttempts = 0;
  lastHtml = null;
  lastImages = [];
  lastRawResponse = null;
  currentMarket = null;

  $jobId.textContent = 'â€“';
  $status.textContent = 'Ready';
  $log.innerHTML = '';
  $json.textContent = '{}';
  updateProgress(0);

  const htmlC = el('htmlContainer');
  if (htmlC) htmlC.innerHTML = '';

  $imgs.innerHTML = '<div class="muted" style="text-align:center;padding:60px 20px">Images will appear here when generation is complete</div>';
  log('UI reset');
}

// =========================
/** Events & init */
// =========================
el('submit').addEventListener('click', startGeneration);
el('checkStatus').addEventListener('click', manualStatusCheck);
el('reset').addEventListener('click', resetUI);
fixJSONContainer();
log('UI ready. Fill out the form and click "Generate Images" to start.');
</script>
</body>
</html>